<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>赛博霓虹手套</title>
    
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>

    <style>
        body {
            margin: 0;
            background-color: #000;
            overflow: hidden;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            /* 禁止手机端长按选中文字等干扰操作 */
            user-select: none;
            -webkit-user-select: none;
            touch-action: none;
        }

        canvas {
            position: absolute;
            top: 0; left: 0;
            width: 100%; height: 100%;
            transform: scaleX(-1); /* 镜像 */
            z-index: 2;
        }

        .input_video { display: none; }

        #error-msg {
            position: absolute;
            top: 20%;
            width: 80%;
            text-align: center;
            color: #ff4444;
            font-family: sans-serif;
            background: rgba(0,0,0,0.8);
            padding: 20px;
            border-radius: 10px;
            display: none;
            z-index: 100;
        }
    </style>
</head>
<body>

    <div id="error-msg"></div>
    <video class="input_video" playsinline></video>
    <canvas class="output_canvas"></canvas>

    <script type="module">
        const videoElement = document.getElementsByClassName('input_video')[0];
        const canvasElement = document.getElementsByClassName('output_canvas')[0];
        const ctx = canvasElement.getContext('2d');
        const errorMsg = document.getElementById('error-msg');

        function resize() {
            // 针对手机高分屏优化清晰度
            const dpr = window.devicePixelRatio || 1;
            canvasElement.width = window.innerWidth * dpr;
            canvasElement.height = window.innerHeight * dpr;
            ctx.scale(dpr, dpr);
            canvasElement.style.width = window.innerWidth + 'px';
            canvasElement.style.height = window.innerHeight + 'px';
        }
        window.addEventListener('resize', resize);
        resize();

        // --- 矢量数学工具函数 ---
        // 用于计算手指边缘坐标
        function getOffsetPoints(p1, p2, width) {
            const dx = p2.x - p1.x;
            const dy = p2.y - p1.y;
            const len = Math.sqrt(dx*dx + dy*dy) || 1; // 防止除以0
            
            // 计算单位法向量 (垂直于骨骼方向)
            const nx = -dy / len;
            const ny = dx / len;

            // 向两侧偏移
            return {
                left: { x: p1.x + nx * width, y: p1.y + ny * width },
                right: { x: p1.x - nx * width, y: p1.y - ny * width },
                nextLeft: { x: p2.x + nx * width, y: p2.y + ny * width },
                nextRight: { x: p2.x - nx * width, y: p2.y - ny * width }
            };
        }

        // --- 核心绘制逻辑：生成手套轮廓 ---
        function drawPerfectOutline(landmarks) {
            const w = canvasElement.width / (window.devicePixelRatio || 1);
            const h = canvasElement.height / (window.devicePixelRatio || 1);
            
            // 将归一化坐标(0-1)转换为像素坐标
            const pts = landmarks.map(lm => ({x: lm.x * w, y: lm.y * h}));

            // 定义手指粗细 (根据手的大小动态调整)
            // 计算手腕(0)到中指根(9)的距离作为参考
            const handSize = Math.hypot(pts[0].x - pts[9].x, pts[0].y - pts[9].y);
            const thickness = handSize * 0.12; // 手指半径系数，调大变胖，调小变瘦

            ctx.beginPath();

            // 我们需要构建一条连续的路径围绕整个手
            // 顺序：手腕 -> 拇指外 -> 拇指尖 -> 拇指内 -> 食指外...
            
            // 1. 手腕左侧 (大致位置)
            // 利用手腕(0)和食指根(5)的方向反推
            const wristOffset = getOffsetPoints(pts[0], pts[5], thickness * 1.2);
            ctx.moveTo(wristOffset.right.x, wristOffset.right.y); // 起点：手腕小拇指侧

            // 定义五根手指的路径顺序 (根部 -> 关节 -> 关节 -> 指尖)
            const fingers = [
                [1, 2, 3, 4],       // 拇指
                [5, 6, 7, 8],       // 食指
                [9, 10, 11, 12],    // 中指
                [13, 14, 15, 16],   // 无名指
                [17, 18, 19, 20]    // 小指
            ];

            // 2. 遍历每一根手指
            for (let i = 0; i < fingers.length; i++) {
                const fingerIndices = fingers[i];
                
                // --- 上行：绘制手指左侧/外侧 ---
                for (let j = 0; j < fingerIndices.length - 1; j++) {
                    const pCurrent = pts[fingerIndices[j]];
                    const pNext = pts[fingerIndices[j+1]];
                    
                    // 指尖稍微细一点，根部粗一点
                    let currentThick = thickness;
                    if (j === fingerIndices.length - 2) currentThick *= 0.8; 

                    const offsets = getOffsetPoints(pCurrent, pNext, currentThick);
                    
                    // 只有拇指(i=0)的第一段需要特殊处理MoveTo，其他都是LineTo
                    // 这里我们采用简化方案，直接连线到每个关节的"左侧"偏移点
                    // 注意：这里的"左"是相对手指指向的
                    // 对于左手/右手，拇指是特殊的，但我们在镜像模式下统一处理
                    
                    if (i === 0 && j === 0) {
                         // 拇指根部特殊连接
                         ctx.quadraticCurveTo(pts[1].x, pts[1].y, offsets.left.x, offsets.left.y);
                    } else {
                        ctx.lineTo(offsets.left.x, offsets.left.y);
                    }
                    ctx.lineTo(offsets.nextLeft.x, offsets.nextLeft.y);
                }

                // --- 指尖圆弧 ---
                const tipIdx = fingerIndices[fingerIndices.length - 1];
                const tipPrevIdx = fingerIndices[fingerIndices.length - 2];
                const tipPt = pts[tipIdx];
                const tipPrevPt = pts[tipPrevIdx];
                const tipOffsets = getOffsetPoints(tipPrevPt, tipPt, thickness * 0.8);
                
                // 画一个半圆包住指尖
                // 控制点设在指尖延伸出去一点的地方
                const dx = tipPt.x - tipPrevPt.x;
                const dy = tipPt.y - tipPrevPt.y;
                const len = Math.hypot(dx, dy);
                const extendX = tipPt.x + (dx/len) * thickness;
                const extendY = tipPt.y + (dy/len) * thickness;

                ctx.bezierCurveTo(
                    tipOffsets.nextLeft.x, tipOffsets.nextLeft.y,
                    extendX, extendY,
                    tipOffsets.nextRight.x, tipOffsets.nextRight.y
                );

                // --- 下行：绘制手指右侧/内侧 ---
                for (let j = fingerIndices.length - 2; j >= 0; j--) {
                    const pCurrent = pts[fingerIndices[j]];
                    const pNext = pts[fingerIndices[j+1]];
                    let currentThick = thickness;
                    if (j === fingerIndices.length - 2) currentThick *= 0.8;

                    const offsets = getOffsetPoints(pCurrent, pNext, currentThick);
                    ctx.lineTo(offsets.right.x, offsets.right.y);
                }

                // --- 指缝连接 (Valley) ---
                if (i < fingers.length - 1) {
                    // 如果不是最后一根手指，连接到下一根手指的根部
                    // 当前手指根部
                    const currentRoot = pts[fingerIndices[0]]; 
                    // 下一根手指根部
                    const nextRoot = pts[fingers[i+1][0]];
                    
                    // 谷底点（两指根部的中点，稍微向手心内收一点）
                    const midX = (currentRoot.x + nextRoot.x) / 2;
                    const midY = (currentRoot.y + nextRoot.y) / 2;
                    
                    // 简单的贝塞尔曲线连接指缝
                    ctx.quadraticCurveTo(midX, midY, midX, midY); 
                }
            }

            // 3. 封口：连接小指外侧回手腕
            const pinkyRoot = pts[17];
            const wrist = pts[0];
            const wristOffsets = getOffsetPoints(wrist, pinkyRoot, thickness * 1.2);
            
            ctx.lineTo(wristOffsets.nextRight.x, wristOffsets.nextRight.y);
            ctx.quadraticCurveTo(wristOffsets.right.x, wristOffsets.right.y, wristOffsets.right.x, wristOffsets.right.y);
            
            // 闭合路径
            ctx.closePath();

            // --- 4. 渲染发光风格 ---
            ctx.lineCap = "round";
            ctx.lineJoin = "round";

            // 第一层：外部强光晕
            ctx.shadowColor = "#FFFFFF"; // 发光颜色
            ctx.shadowBlur = 30;
            ctx.strokeStyle = "#FFFFFF";
            ctx.lineWidth = 4;
            ctx.stroke();

            // 第二层：核心高亮 (让线条中心更亮)
            ctx.shadowBlur = 0;
            ctx.lineWidth = 2;
            ctx.strokeStyle = "#FFFFFF"; 
            ctx.stroke();
        }

        function onResults(results) {
            // 清空画布
            ctx.clearRect(0, 0, canvasElement.width, canvasElement.height);

            if (results.multiHandLandmarks) {
                for (const landmarks of results.multiHandLandmarks) {
                    drawPerfectOutline(landmarks);
                }
            }
        }

        const hands = new Hands({locateFile: (file) => {
            return `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`;
        }});

        hands.setOptions({
            maxNumHands: 2,
            modelComplexity: 1,
            minDetectionConfidence: 0.5,
            minTrackingConfidence: 0.5
        });

        hands.onResults(onResults);

        const camera = new Camera(videoElement, {
            onFrame: async () => {
                await hands.send({image: videoElement});
            },
            width: 1280,
            height: 720
        });

        camera.start().catch(err => {
            console.error(err);
            errorMsg.style.display = 'block';
            errorMsg.innerHTML = `
                <h3>无法启动摄像头</h3>
                <p>错误代码: ${err.name}</p>
                <p><strong>解决方案：</strong></p>
                <ul style="text-align:left; display:inline-block;">
                    <li>请确保你使用的是 <strong>HTTPS</strong> 协议访问网页。</li>
                    <li>如果是本地开发，请使用 localhost (不要用 IP)。</li>
                    <li>iOS/Android 必须使用 HTTPS。</li>
                </ul>
            `;
        });
    </script>
</body>
</html>