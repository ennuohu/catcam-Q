<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>手机端手势识别修复版</title>
    
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>

    <style>
        body {
            margin: 0;
            background-color: #000;
            overflow: hidden;
            touch-action: none;
            font-family: monospace;
        }

        /* 全屏画布 */
        canvas {
            position: absolute;
            top: 0; left: 0;
            width: 100%; height: 100%;
            transform: scaleX(-1); /* 镜像翻转，像照镜子一样 */
            z-index: 2;
        }

        /* 调试用：左上角显示原始摄像头画面 */
        .input_video {
            position: absolute;
            top: 10px;
            left: 10px;
            width: 120px; /* 小窗口 */
            height: auto;
            z-index: 10;
            border: 2px solid red; /* 红框表示正在运行 */
            opacity: 0.6;
            transform: scaleX(-1);
        }

        /* 屏幕日志打印区 */
        #logs {
            position: absolute;
            bottom: 20px;
            left: 10px;
            right: 10px;
            color: #0f0; /* 绿色文字 */
            background: rgba(0,0,0,0.7);
            padding: 10px;
            pointer-events: none;
            z-index: 20;
            font-size: 14px;
            white-space: pre-wrap;
            border-radius: 8px;
        }
    </style>
</head>
<body>

    <!-- 原始视频流 (调试用) -->
    <video class="input_video" playsinline muted autoplay></video>
    
    <!-- 绘制层 -->
    <canvas class="output_canvas"></canvas>

    <!-- 日志显示 -->
    <div id="logs">系统初始化中...</div>

    <script type="module">
        const videoElement = document.getElementsByClassName('input_video')[0];
        const canvasElement = document.getElementsByClassName('output_canvas')[0];
        const ctx = canvasElement.getContext('2d');
        const logBox = document.getElementById('logs');

        // 日志打印函数
        function log(text) {
            const time = new Date().toLocaleTimeString();
            logBox.innerText = `[${time}] ${text}\n` + logBox.innerText.slice(0, 200);
        }

        function resize() {
            const dpr = window.devicePixelRatio || 1;
            canvasElement.width = window.innerWidth * dpr;
            canvasElement.height = window.innerHeight * dpr;
            ctx.scale(dpr, dpr);
        }
        window.addEventListener('resize', resize);
        resize();

        // --- 平滑轮廓算法 (保持不变) ---
        function getSmoothContour(landmarks, width, height) {
            const contourPoints = [];
            const fingers = [[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16], [17, 18, 19, 20]];
            const pts = landmarks.map(l => ({x: l.x * width, y: l.y * height}));
            const handSize = Math.hypot(pts[0].x - pts[9].x, pts[0].y - pts[9].y);
            const offset = handSize * 0.12; 

            const addPoint = (p1, p2, dist, side) => {
                const angle = Math.atan2(p2.y - p1.y, p2.x - p1.x);
                const normal = angle + (side * Math.PI / 2); 
                return { x: p1.x + Math.cos(normal) * dist, y: p1.y + Math.sin(normal) * dist };
            };

            contourPoints.push(addPoint(pts[0], pts[5], offset * 1.5, -1));

            for (let i = 0; i < fingers.length; i++) {
                const indices = fingers[i];
                for (let j = 0; j < indices.length - 1; j++) contourPoints.push(addPoint(pts[indices[j]], pts[indices[j+1]], offset, 1));
                
                const tipIdx = indices[indices.length - 1];
                const prevIdx = indices[indices.length - 2];
                const angle = Math.atan2(pts[tipIdx].y - pts[prevIdx].y, pts[tipIdx].x - pts[prevIdx].x);
                contourPoints.push({ x: pts[tipIdx].x + Math.cos(angle)*(offset*1.2), y: pts[tipIdx].y + Math.sin(angle)*(offset*1.2) });

                for (let j = indices.length - 2; j >= 0; j--) contourPoints.push(addPoint(pts[indices[j]], pts[indices[j+1]], offset, -1));
                
                if (i < fingers.length - 1) {
                    const currRoot = pts[indices[0]];
                    const nextRoot = pts[fingers[i+1][0]];
                    contourPoints.push({ x: (currRoot.x + nextRoot.x)/2, y: (currRoot.y + nextRoot.y)/2 });
                }
            }
            contourPoints.push(addPoint(pts[0], pts[17], offset * 1.5, 1));
            return contourPoints;
        }

        function drawSmoothPath(ctx, points) {
            if (points.length < 2) return;
            ctx.beginPath();
            ctx.moveTo(points[0].x, points[0].y);
            for (let i = 1; i < points.length - 1; i++) {
                const midX = (points[i].x + points[i+1].x) / 2;
                const midY = (points[i].y + points[i+1].y) / 2;
                ctx.quadraticCurveTo(points[i].x, points[i].y, midX, midY);
            }
            ctx.lineTo(points[points.length-1].x, points[points.length-1].y);
            ctx.quadraticCurveTo(points[points.length-1].x, points[points.length-1].y, points[0].x, points[0].y);
            ctx.closePath();
            
            ctx.shadowColor = "#FFFFFF";
            ctx.shadowBlur = 20;
            ctx.strokeStyle = "#FFFFFF";
            ctx.lineWidth = 4;
            ctx.lineJoin = "round";
            ctx.lineCap = "round";
            ctx.stroke();
            
            ctx.shadowBlur = 0;
            ctx.lineWidth = 2;
            ctx.stroke();
        }

        // --- 核心逻辑 ---

        function onResults(results) {
            // 清空画布
            const dpr = window.devicePixelRatio || 1;
            ctx.clearRect(0, 0, canvasElement.width / dpr, canvasElement.height / dpr);

            if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
                log("检测到手部! 正在绘制...");
                for (const landmarks of results.multiHandLandmarks) {
                    const w = canvasElement.width / dpr;
                    const h = canvasElement.height / dpr;
                    const rawPoints = getSmoothContour(landmarks, w, h);
                    drawSmoothPath(ctx, rawPoints);
                }
            } else {
                log("画面正常 - 未检测到手 (请举手)");
            }
        }

        log("正在加载 MediaPipe 模型...");

        const hands = new Hands({locateFile: (file) => {
            return `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`;
        }});

        hands.setOptions({
            maxNumHands: 2,
            modelComplexity: 0, // 手机端改为0 (Lite模型)，速度更快
            minDetectionConfidence: 0.5,
            minTrackingConfidence: 0.5
        });

        hands.onResults(onResults);

        // 使用自定义的 Camera 初始化，不锁定分辨率
        const camera = new Camera(videoElement, {
            onFrame: async () => {
                await hands.send({image: videoElement});
            },
            facingMode: "user", // 强制使用前置摄像头
            width: 640,         // 降低分辨率以兼容更多低端机型
            height: 480
        });

        log("正在请求摄像头权限...");

        camera.start()
            .then(() => {
                log("摄像头启动成功！等待画面...");
                // 强制播放视频，解决部分iOS不自动播放问题
                videoElement.play();
            })
            .catch(err => {
                console.error(err);
                log("错误: " + err.message);
                log("请检查是否在 HTTPS 环境，且已允许权限");
            });

    </script>
</body>
</html>
