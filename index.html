<!DOCTYPE html>
<html lang="zh-CN">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <title>çŒ«å’ªæ‰‹åŠ¿è·Ÿè¸ª - çƒŸèŠ±ç‰ˆ</title>
    <link rel="stylesheet" href="style.css">
    <style>
        #fireworks-canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 20;
            pointer-events: none;
        }

        #scene-container {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 10;
            pointer-events: none;
        }

        /* å‘¼å¸ç¯ DOM å…ƒç´  */
        #charging-effect {
            position: absolute;
            width: 40px;
            height: 40px;
            border-radius: 50%;
            background: radial-gradient(circle, rgba(255, 255, 255, 1) 0%, rgba(255, 255, 255, 0.5) 40%, rgba(255, 255, 255, 0) 70%);
            transform: translate(-50%, -50%);
            pointer-events: none;
            z-index: 30;
            /* åœ¨çƒŸèŠ±ä¹‹ä¸Š */
            display: none;
            box-shadow: 0 0 20px rgba(255, 255, 255, 0.6);
            transition: opacity 0.1s;
        }

        #webcam {
            z-index: 1;
        }
    </style>
</head>

<body>
    <div id="loading">
        <div class="spinner"></div>
        <p id="load-status">æ­£åœ¨åŠ è½½...</p>
        <p class="hint" id="load-hint">è¯·ç¨å€™</p>
    </div>

    <div id="app">
        <video id="webcam" autoplay playsinline style="position:absolute;opacity:0;width:1px;height:1px;"></video>
        <div id="scene-container"></div>
        <canvas id="fireworks-canvas"></canvas>
        <div id="charging-effect"></div>

        <div id="status">
            <div class="status-dot"></div>
            <span id="status-text">åˆå§‹åŒ–ä¸­...</span>
        </div>
    </div>

    <!-- Import Map: ç°ä»£æµè§ˆå™¨æ ‡å‡†åŠ è½½æ–¹å¼ -->
    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>

    <!-- ä¸»é€»è¾‘ï¼šES Module -->
    <script type="module">
        import * as THREE from 'three';
        import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
        import { RoomEnvironment } from 'three/addons/environments/RoomEnvironment.js';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

        // æŒ‚è½½åˆ°å…¨å±€ï¼Œä¾›åç»­æ™®é€šè„šæœ¬ä½¿ç”¨
        window.THREE = THREE;
        window.GLTFLoader = GLTFLoader;
        window.RoomEnvironment = RoomEnvironment;
        window.OrbitControls = OrbitControls;
        console.log('âœ… Three.js, GLTFLoader, RoomEnvironment, OrbitControls æ¨¡å—å·²åŠ è½½');

        // å¯åŠ¨æ ‡è®°
        window.modulesReady = true;
    </script>

    <script>
        // å…¨å±€å˜é‡
        let camera, scene, renderer, catModel;
        let videoElement;
        let hands, cameraHelper;
        let handDetected = false;
        let handScreenX = 0, handScreenY = 0; // æ‰‹åœ¨å±å¹•ä¸Šçš„åƒç´ åæ ‡
        let handPosition = { x: 0, y: 0 };
        let targetRotation = { x: 0, y: 0 };
        let currentRotation = { x: 0, y: 0 };
        let mouseX = 0, mouseY = 0;
        let useHandTracking = false;
        let mediaPipeLoaded = false;

        // æ‰‹åŠ¿çŠ¶æ€
        let isHandOpen = false; // æ˜¯å¦å¼ å¼€æ‰‹æŒ
        let handOpenness = 0; // æ‰‹æŒå¼ å¼€ç¨‹åº¦ 0-1
        let detectionStableCount = 0; // ç¨³å®šæ£€æµ‹è®¡æ•°
        const STABLE_FRAMES_REQUIRED = 0; // ç«‹å³å“åº”ï¼Œä¸éœ€è¦ç¨³å®šå¸§

        // çƒŸèŠ±ç³»ç»Ÿ
        let fireworksCanvas, fireworksCtx;
        let particles = [];
        let trailParticles = [];
        const MAX_PARTICLES = 500;

        // GLBæ¨¡å‹ç³»ç»Ÿ
        let glbLoader = null;
        let catModel1 = null; // cat.glb (æ¡æ‹³çŠ¶æ€)
        let catModel2 = null; // cat-2.glb (å¼ å¼€çŠ¶æ€)
        let currentModelState = null; // 'closed' æˆ– 'open'
        let currentModelName = null; // å½“å‰æ¨¡å‹çš„åç§° (æ–‡ä»¶å)
        let modelsLoaded = false;

        // ç›¸æœºæ§åˆ¶ç³»ç»Ÿ
        let controls = null;
        let isCameraEditing = false;
        let defaultCameraSettings = {
            'cat.glb': { position: { x: 0, y: 0.3, z: 2.5 }, target: { x: 0, y: 0, z: 0 } },
            'cat-2.glb': { position: { x: 0, y: 0.3, z: 2.5 }, target: { x: 0, y: 0, z: 0 } }
        };
        let cameraSettings = JSON.parse(localStorage.getItem('catcam_camera_settings_v2')) || defaultCameraSettings;

        // ä¿å­˜ç›¸æœºè®¾ç½®
        function saveCameraSettings() {
            if (!currentModelName || !controls) return;

            cameraSettings[currentModelName] = {
                position: {
                    x: camera.position.x,
                    y: camera.position.y,
                    z: camera.position.z
                },
                target: {
                    x: controls.target.x,
                    y: controls.target.y,
                    z: controls.target.z
                }
            };

            localStorage.setItem('catcam_camera_settings_v2', JSON.stringify(cameraSettings));
            console.log(`ğŸ’¾ å·²ä¿å­˜ [${currentModelName}] æ¨¡å‹è§†è§’å‚æ•°:`, cameraSettings[currentModelName]);
        }

        // åº”ç”¨ç›¸æœºè®¾ç½®
        function applyCameraSettings(modelName) {
            const settings = cameraSettings[modelName] || defaultCameraSettings[modelName] || defaultCameraSettings['cat.glb'];
            if (camera && settings) {
                camera.position.set(settings.position.x, settings.position.y, settings.position.z);
                if (controls) {
                    controls.target.set(settings.target.x, settings.target.y, settings.target.z);
                    controls.update();
                }
                console.log(`ğŸ“¸ å·²åº”ç”¨ [${modelName}] è§†è§’`);
            }
        }
        class FireworkParticle {
            constructor(x, y, angle, speed, hue) {
                this.x = x;
                this.y = y;
                this.vx = Math.cos(angle) * speed;
                this.vy = Math.sin(angle) * speed;
                this.life = 1.0;
                this.decay = 0.015 + Math.random() * 0.01;
                this.size = 3 + Math.random() * 3;
                this.hue = hue;
                this.saturation = 80 + Math.random() * 20;
                this.lightness = 50 + Math.random() * 20;
                this.alpha = 1.0;
            }

            update() {
                this.vx *= 0.98; // æ‘©æ“¦åŠ›
                this.vy *= 0.98;
                this.vy += 0.1; // é‡åŠ›
                this.x += this.vx;
                this.y += this.vy;
                this.life -= this.decay;
                this.alpha = this.life;
            }

            draw(ctx) {
                ctx.save();

                // å…‰æ™•æ•ˆæœ
                const gradient = ctx.createRadialGradient(this.x, this.y, 0, this.x, this.y, this.size * 3);
                gradient.addColorStop(0, `hsla(${this.hue}, ${this.saturation}%, ${this.lightness}%, ${this.alpha * 0.8})`);
                gradient.addColorStop(0.5, `hsla(${this.hue}, ${this.saturation}%, ${this.lightness}%, ${this.alpha * 0.3})`);
                gradient.addColorStop(1, `hsla(${this.hue}, ${this.saturation}%, ${this.lightness}%, 0)`);

                ctx.beginPath();
                ctx.arc(this.x, this.y, this.size * 3, 0, Math.PI * 2);
                ctx.fillStyle = gradient;
                ctx.fill();

                // æ ¸å¿ƒäº®ç‚¹
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
                ctx.fillStyle = `hsla(${this.hue}, 100%, 80%, ${this.alpha})`;
                ctx.fill();

                ctx.restore();
            }
        }

        // æ‹–å°¾ç²’å­ç±»
        class TrailParticle {
            constructor(x, y, hue) {
                this.x = x;
                this.y = y;
                this.life = 1.0;
                this.decay = 0.05;
                this.size = 5 + Math.random() * 5;
                this.hue = hue;
            }

            update() {
                this.life -= this.decay;
            }

            draw(ctx) {
                ctx.save();
                const gradient = ctx.createRadialGradient(this.x, this.y, 0, this.x, this.y, this.size * 2);
                gradient.addColorStop(0, `hsla(${this.hue}, 100%, 70%, ${this.life * 0.6})`);
                gradient.addColorStop(1, `hsla(${this.hue}, 100%, 50%, 0)`);

                ctx.beginPath();
                ctx.arc(this.x, this.y, this.size * 2, 0, Math.PI * 2);
                ctx.fillStyle = gradient;
                ctx.fill();
                ctx.restore();
            }
        }

        // åˆå§‹åŒ–çƒŸèŠ±Canvas
        function initFireworks() {
            fireworksCanvas = document.getElementById('fireworks-canvas');
            fireworksCtx = fireworksCanvas.getContext('2d');
            fireworksCanvas.width = window.innerWidth;
            fireworksCanvas.height = window.innerHeight;

            window.addEventListener('resize', () => {
                fireworksCanvas.width = window.innerWidth;
                fireworksCanvas.height = window.innerHeight;
            });
        }

        // åˆ›å»ºçƒŸèŠ±çˆ†å‘
        function createFireworkBurst(x, y, hue) {
            const particleCount = 25 + Math.floor(Math.random() * 15);
            const angleStep = (Math.PI * 2) / particleCount;

            for (let i = 0; i < particleCount; i++) {
                const angle = angleStep * i + Math.random() * 0.2;
                const speed = 2 + Math.random() * 3;
                particles.push(new FireworkParticle(x, y, angle, speed, hue));
            }
        }

        // æ›´æ–°å’Œç»˜åˆ¶çƒŸèŠ±
        function updateFireworks() {
            // ä½¿ç”¨ destination-out å®ç°é€æ˜æ·¡å‡ºï¼Œè€Œä¸æ˜¯å åŠ é»‘è‰²
            fireworksCtx.globalCompositeOperation = 'destination-out';
            fireworksCtx.fillStyle = 'rgba(0, 0, 0, 0.1)';
            fireworksCtx.fillRect(0, 0, fireworksCanvas.width, fireworksCanvas.height);
            fireworksCtx.globalCompositeOperation = 'source-over';

            // å¦‚æœæ£€æµ‹åˆ°æ‰‹åŠ¿
            if (handDetected) {
                if (isHandOpen) {
                    // å¼ å¼€æ‰‹æŒ - ç»½æ”¾å½©è‰²çƒŸèŠ±
                    const hue = (Date.now() % 3000) / 3000 * 360;

                    // æŒç»­æ·»åŠ æ‹–å°¾ç²’å­
                    trailParticles.push(new TrailParticle(handScreenX, handScreenY, hue));

                    // å¢åŠ çƒŸèŠ±ç”Ÿæˆæ¦‚ç‡ï¼ˆæ¯å¸§60%æ¦‚ç‡ç”Ÿæˆï¼‰
                    if (Math.random() < 0.6) {
                        createFireworkBurst(handScreenX, handScreenY, hue);
                    }

                    // é¢å¤–å¢åŠ ä¸€äº›å°çƒŸèŠ±å¢å¼ºæ•ˆæœ
                    if (Math.random() < 0.3) {
                        const offsetX = (Math.random() - 0.5) * 20;
                        const offsetY = (Math.random() - 0.5) * 20;
                        createFireworkBurst(handScreenX + offsetX, handScreenY + offsetY, hue + Math.random() * 60);
                    }
                }
                // (DOMå±‚å·²å¤„ç†ææ‹³çŠ¶æ€çš„æ˜¾ç¤º)
            }

            // ... (ç²’å­æ›´æ–°é€»è¾‘ä¿æŒä¸å˜)

            // æ›´æ–°æ‹–å°¾ç²’å­
            trailParticles = trailParticles.filter(p => {
                p.update();
                if (p.life > 0) {
                    p.draw(fireworksCtx);
                    return true;
                }
                return false;
            });

            // æ›´æ–°çƒŸèŠ±ç²’å­
            particles = particles.filter(p => {
                p.update();
                if (p.life > 0) {
                    p.draw(fireworksCtx);
                    return true;
                }
                return false;
            });

            // é™åˆ¶ç²’å­æ•°é‡
            while (particles.length > MAX_PARTICLES) {
                particles.shift();
            }
        }

        // ... existing code ...

        // åˆå§‹åŒ–
        async function init() {
            console.log('ğŸš€ åˆå§‹åŒ–åº”ç”¨...');

            // ç­‰å¾…ESæ¨¡å—åŠ è½½
            let retries = 0;
            while (!window.modulesReady && retries < 20) {
                await new Promise(r => setTimeout(r, 100));
                retries++;
            }

            if (typeof THREE === 'undefined') {
                alert('Three.jsæ¨¡å—åŠ è½½å¤±è´¥ï¼Œè¯·åˆ·æ–°');
                return;
            }

            initFireworks();
            initThreeJS();

            // ... existing code ...

            updateLoadStatus('æ­£åœ¨åŠ è½½æ‰‹åŠ¿è¯†åˆ«...', 'è¿™å¯èƒ½éœ€è¦å‡ ç§’é’Ÿ');

            try {
                await loadMediaPipe();
                await initCamera();
                await initHandTracking();
                useHandTracking = true;
                document.getElementById('status-text').textContent = 'ä¼¸å‡ºæ‰‹æŒçœ‹çƒŸèŠ±ï¼';
            } catch (error) {
                // ... fallback ...
                console.warn(error);
                useHandTracking = false;
                setupTouchMode();
                document.getElementById('status-text').textContent = 'è§¦æ‘¸æ¨¡å¼';
            }

            animate();

            setTimeout(() => {
                document.getElementById('loading').classList.add('hidden');
                document.getElementById('app').classList.add('active');
            }, 500);

            console.log('âœ… åº”ç”¨åˆå§‹åŒ–å®Œæˆ');
        }

        // ... existing code ...

        // åŠ è½½GLBæ¨¡å‹
        async function loadGLBModels() {
            console.log('ğŸ± å¼€å§‹åŠ è½½GLBæ¨¡å‹...');

            // æ­¤æ—¶ GLTFLoader åº”è¯¥å·²ç»åœ¨ window ä¸Šäº†
            if (!window.GLTFLoader) {
                console.error('âŒ GLTFLoaderæœªåŠ è½½ï¼Œä½¿ç”¨å¤‡ç”¨æ¨¡å‹');
                createFallbackModel();
                return;
            }

            glbLoader = new window.GLTFLoader();

            try {
                // é¢„åŠ è½½ä¸¤ä¸ªæ¨¡å‹
                const [model1, model2] = await Promise.all([
                    loadSingleGLB('models/cat.glb'),
                    loadSingleGLB('models/cat-2.glb')
                ]);

                catModel1 = model1;
                catModel2 = model2;

                // é»˜è®¤æ˜¾ç¤ºæ¡æ‹³æ¨¡å‹
                catModel = catModel1;
                scene.add(catModel);
                currentModelState = 'closed';
                modelsLoaded = true;

                console.log('âœ… ä¸¤ä¸ªGLBæ¨¡å‹åŠ è½½æˆåŠŸ');
            } catch (error) {
                console.error('âŒ GLBæ¨¡å‹åŠ è½½å¤±è´¥:', error);
                createFallbackModel();
            }
        }

        // æ›´æ–°DOMå±‚å‘¼å¸ç¯ä½ç½®
        function updateChargingEffect() {
            const el = document.getElementById('charging-effect');
            if (handDetected && !isHandOpen) {
                el.style.display = 'block';
                el.style.left = handScreenX + 'px';
                el.style.top = handScreenY + 'px';

                // å‘¼å¸åŠ¨ç”»
                const time = Date.now() * 0.003;
                const scale = 1 + Math.sin(time * 3) * 0.2; // å¿«é€Ÿå‘¼å¸
                el.style.transform = `translate(-50%, -50%) scale(${scale})`;
                el.style.opacity = Math.sin(time * 3) * 0.2 + 0.8;
            } else {
                el.style.display = 'none';
            }
        }

        // æ›´æ–°åŠ è½½çŠ¶æ€
        function updateLoadStatus(status, hint = '') {
            document.getElementById('load-status').textContent = status;
            if (hint) document.getElementById('load-hint').textContent = hint;
            console.log(status, hint);
        }

        // åˆå§‹åŒ–
        async function init() {
            console.log('ğŸš€ åˆå§‹åŒ–åº”ç”¨...');

            // ç­‰å¾…ESæ¨¡å—åŠ è½½
            let retries = 0;
            while (!window.modulesReady && retries < 50) {
                await new Promise(r => setTimeout(r, 100));
                retries++;
            }

            if (typeof THREE === 'undefined') {
                alert('Three.jsæ¨¡å—åŠ è½½å¤±è´¥ï¼Œè¯·åˆ·æ–°');
                return;
            }

            initFireworks();
            initThreeJS();

            updateLoadStatus('æ­£åœ¨åŠ è½½æ‰‹åŠ¿è¯†åˆ«...', 'è¿™å¯èƒ½éœ€è¦å‡ ç§’é’Ÿ');

            try {
                await loadMediaPipe();
                await initCamera();
                await initHandTracking();
                useHandTracking = true;
                document.getElementById('status-text').textContent = 'ä¼¸å‡ºæ‰‹æŒçœ‹çƒŸèŠ±ï¼';
            } catch (error) {
                console.warn('æ‰‹åŠ¿è·Ÿè¸ªåˆå§‹åŒ–å¤±è´¥ï¼Œä½¿ç”¨è§¦æ‘¸æ¨¡å¼:', error);
                useHandTracking = false;
                setupTouchMode();
                document.getElementById('status-text').textContent = 'è§¦æ‘¸å±å¹•çœ‹çƒŸèŠ±';
            }

            animate();

            setTimeout(() => {
                document.getElementById('loading').classList.add('hidden');
                document.getElementById('app').classList.add('active');
            }, 500);

            console.log('âœ… åº”ç”¨åˆå§‹åŒ–å®Œæˆ');
        }

        // ... existing code ...

        // åŠ è½½GLBæ¨¡å‹
        async function loadGLBModels() {
            console.log('ğŸ± å¼€å§‹åŠ è½½GLBæ¨¡å‹...');

            // æ­¤æ—¶ GLTFLoader åº”è¯¥å·²ç»åœ¨ window ä¸Šäº†
            if (!window.GLTFLoader) {
                console.error('âŒ GLTFLoaderæœªåŠ è½½ï¼Œä½¿ç”¨å¤‡ç”¨æ¨¡å‹');
                // è°ƒè¯•ä¿¡æ¯
                console.log('Window keys:', Object.keys(window).filter(k => k.includes('GLTF')));
                createFallbackModel();
                return;
            }

            glbLoader = new window.GLTFLoader();

            try {
                // é¢„åŠ è½½ä¸¤ä¸ªæ¨¡å‹
                const [model1, model2] = await Promise.all([
                    loadSingleGLB('models/cat.glb'),
                    loadSingleGLB('models/cat-2.glb')
                ]);

                catModel1 = model1;
                catModel2 = model2;

                // é»˜è®¤æ˜¾ç¤ºæ¡æ‹³æ¨¡å‹
                catModel = catModel1;
                scene.add(catModel);
                currentModelState = 'closed';
                modelsLoaded = true;

                console.log('âœ… ä¸¤ä¸ªGLBæ¨¡å‹åŠ è½½æˆåŠŸ');
            } catch (error) {
                console.error('âŒ GLBæ¨¡å‹åŠ è½½å¤±è´¥:', error);
                createFallbackModel();
            }
        }

        // åŠ è½½MediaPipeåº“
        function loadMediaPipe() {
            return new Promise((resolve, reject) => {
                const timeout = setTimeout(() => reject(new Error('MediaPipeåŠ è½½è¶…æ—¶')), 15000);

                const scripts = [
                    'https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js',
                    'https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js',
                    'https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js'
                ];

                Promise.all(scripts.map(src => {
                    return new Promise((res, rej) => {
                        const script = document.createElement('script');
                        script.src = src;
                        script.onload = res;
                        script.onerror = () => rej(new Error(`Failed to load ${src}`));
                        document.head.appendChild(script);
                    });
                }))
                    .then(() => {
                        clearTimeout(timeout);
                        mediaPipeLoaded = true;
                        console.log('âœ… MediaPipeåŠ è½½æˆåŠŸ');
                        resolve();
                    })
                    .catch(err => {
                        clearTimeout(timeout);
                        reject(err);
                    });
            });
        }

        // åˆå§‹åŒ–æ‘„åƒå¤´
        async function initCamera() {
            updateLoadStatus('è¯·æ±‚æ‘„åƒå¤´æƒé™...', '');
            videoElement = document.getElementById('webcam');

            const stream = await navigator.mediaDevices.getUserMedia({
                video: { facingMode: 'user', width: { ideal: 640 }, height: { ideal: 480 } },
                audio: false
            });

            videoElement.srcObject = stream;
            await new Promise(resolve => {
                videoElement.onloadedmetadata = resolve;
            });

            console.log('âœ… æ‘„åƒå¤´åˆå§‹åŒ–æˆåŠŸ');
        }

        // åˆå§‹åŒ–æ‰‹åŠ¿è·Ÿè¸ª
        async function initHandTracking() {
            if (!mediaPipeLoaded || typeof Hands === 'undefined') {
                throw new Error('MediaPipeæœªåŠ è½½');
            }

            updateLoadStatus('åˆå§‹åŒ–æ‰‹åŠ¿è¯†åˆ«...', '');

            hands = new Hands({
                locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`
            });

            hands.setOptions({
                maxNumHands: 1,
                modelComplexity: 0,
                minDetectionConfidence: 0.5,
                minTrackingConfidence: 0.5
            });

            hands.onResults(onHandResults);

            cameraHelper = new Camera(videoElement, {
                onFrame: async () => await hands.send({ image: videoElement }),
                width: 640,
                height: 480
            });
            cameraHelper.start();

            console.log('âœ… æ‰‹åŠ¿è·Ÿè¸ªåˆå§‹åŒ–æˆåŠŸ');
        }


        // è®¡ç®—æ‰‹æŒ‡å¼ å¼€ç¨‹åº¦
        function calculateHandOpenness(landmarks) {
            // è®¡ç®—æ‰‹æŒ‡å°–å’Œæ‰‹æŒä¸­å¿ƒçš„è·ç¦»
            const palmCenter = landmarks[9]; // ä¸­æŒ‡æŒéª¨å…³èŠ‚
            const wrist = landmarks[0]; // æ‰‹è…•

            // è®¡ç®—å„æ‰‹æŒ‡å°–åˆ°æ‰‹æŒä¸­å¿ƒçš„è·ç¦»
            const thumbTip = landmarks[4];
            const indexTip = landmarks[8];
            const middleTip = landmarks[12];
            const ringTip = landmarks[16];
            const pinkyTip = landmarks[20];

            // è®¡ç®—è·ç¦»ï¼ˆå½’ä¸€åŒ–åæ ‡ï¼‰
            const distance = (p1, p2) => {
                const dx = p1.x - p2.x;
                const dy = p1.y - p2.y;
                return Math.sqrt(dx * dx + dy * dy);
            };

            // æ‰‹æŒåŸºå‡†è·ç¦»ï¼ˆæ‰‹è…•åˆ°ä¸­æŒ‡æ ¹éƒ¨ï¼‰
            const palmLength = distance(wrist, palmCenter);

            // å„æ‰‹æŒ‡çš„ä¼¸å±•è·ç¦»
            const thumbDist = distance(thumbTip, palmCenter) / palmLength;
            const indexDist = distance(indexTip, palmCenter) / palmLength;
            const middleDist = distance(middleTip, palmCenter) / palmLength;
            const ringDist = distance(ringTip, palmCenter) / palmLength;
            const pinkyDist = distance(pinkyTip, palmCenter) / palmLength;

            // å¹³å‡è·ç¦»
            const avgDist = (thumbDist + indexDist + middleDist + ringDist + pinkyDist) / 5;

            // è¯¦ç»†è°ƒè¯•ä¿¡æ¯
            console.log(`ğŸ“ æ‰‹æŒ‡è·ç¦» - æ‹‡æŒ‡:${thumbDist.toFixed(2)} é£ŸæŒ‡:${indexDist.toFixed(2)} ä¸­æŒ‡:${middleDist.toFixed(2)} æ— åæŒ‡:${ringDist.toFixed(2)} å°æŒ‡:${pinkyDist.toFixed(2)} | å¹³å‡:${avgDist.toFixed(2)}`);

            // å½’ä¸€åŒ–åˆ°0-1èŒƒå›´
            // ææ‹³æ—¶çº¦1.2ï¼Œå¼ å¼€æ—¶çº¦2.0-2.5
            const openness = Math.max(0, Math.min(1, (avgDist - 1.2) / 0.8));

            return openness;
        }

        // æ‰‹åŠ¿æ£€æµ‹ç»“æœ
        function onHandResults(results) {
            if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
                const landmarks = results.multiHandLandmarks[0];
                const palmCenter = landmarks[9];

                // è®¡ç®—ç›®æ ‡ä½ç½®
                const targetHandX = (1 - palmCenter.x) * 2 - 1;
                const targetHandY = palmCenter.y * 2 - 1;
                const targetScreenX = (1 - palmCenter.x) * window.innerWidth;
                const targetScreenY = palmCenter.y * window.innerHeight;

                // å¹³æ»‘æ’å€¼ï¼ˆè®©ç§»åŠ¨ä¸æ»‘ï¼‰
                const posSmooth = 0.35;
                handPosition.x = handPosition.x * (1 - posSmooth) + targetHandX * posSmooth;
                handPosition.y = handPosition.y * (1 - posSmooth) + targetHandY * posSmooth;
                handScreenX = handScreenX * (1 - posSmooth) + targetScreenX * posSmooth;
                handScreenY = handScreenY * (1 - posSmooth) + targetScreenY * posSmooth;

                // è®¡ç®—æ‰‹åŠ¿å¼ å¼€ç¨‹åº¦
                const currentOpenness = calculateHandOpenness(landmarks);

                // å¹³æ»‘è¿‡æ¸¡ï¼ˆé¿å…æŠ–åŠ¨ï¼‰
                handOpenness = handOpenness * 0.7 + currentOpenness * 0.3;

                // åˆ¤æ–­æ˜¯å¦å¼ å¼€ï¼ˆå¤§å¹…é™ä½é˜ˆå€¼åˆ°0.15ï¼Œè¶…é«˜æ•æ„Ÿåº¦ï¼‰
                const wasOpen = isHandOpen;
                isHandOpen = handOpenness > 0.15;

                // ç¨³å®šæ€§æ£€æµ‹ï¼ˆå‡å°‘åˆ°2å¸§ï¼Œæ›´å¿«å“åº”ï¼‰
                if (isHandOpen === wasOpen) {
                    detectionStableCount++;
                } else {
                    detectionStableCount = 0;
                }



                handDetected = true;
                updateStatus(true, isHandOpen);
            } else {
                handDetected = false;
                isHandOpen = false;
                handOpenness = 0;
                detectionStableCount = 0;
                updateStatus(false, false);
            }
        }

        // è®¾ç½®è§¦æ‘¸æ¨¡å¼
        function setupTouchMode() {
            document.addEventListener('mousemove', onPointerMove);
            document.addEventListener('touchmove', onTouchMove);
        }

        function onPointerMove(event) {
            mouseX = (event.clientX / window.innerWidth) * 2 - 1;
            mouseY = (event.clientY / window.innerHeight) * 2 - 1;
            handScreenX = event.clientX;
            handScreenY = event.clientY;
            handDetected = true;
        }

        function onTouchMove(event) {
            event.preventDefault();
            if (event.touches.length > 0) {
                mouseX = (event.touches[0].clientX / window.innerWidth) * 2 - 1;
                mouseY = (event.touches[0].clientY / window.innerHeight) * 2 - 1;
                handScreenX = event.touches[0].clientX;
                handScreenY = event.touches[0].clientY;
                handDetected = true;
            }
        }

        // æ›´æ–°çŠ¶æ€
        function updateStatus(detected, handOpen = false) {
            const dot = document.querySelector('.status-dot');
            const text = document.getElementById('status-text');

            if (useHandTracking) {
                if (detected) {
                    dot.classList.add('active');
                    if (handOpen) {
                        text.textContent = 'âœ¨';
                    } else {
                        text.textContent = 'âšª';
                    }
                } else {
                    dot.classList.remove('active');
                    text.textContent = 'ä¼¸å‡ºçŒ«çˆªè¯•è¯•';
                }
            } else {
                if (detected) {
                    dot.classList.add('active');
                    text.textContent = 'âœ¨ çƒŸèŠ±ç»½æ”¾ä¸­';
                } else {
                    dot.classList.remove('active');
                    text.textContent = 'è§¦æ‘¸å±å¹•çœ‹çƒŸèŠ±';
                }
            }
        }

        // Three.jsåœºæ™¯
        function initThreeJS() {
            const container = document.getElementById('scene-container');
            scene = new THREE.Scene();
            // èƒŒæ™¯è®¾ä¸ºçº¯é»‘
            scene.background = new THREE.Color(0x000000);

            // ğŸ¬ è°ƒæ•´ç›¸æœºè§†è§’ï¼šä¸ŠåŠèº«ç‰¹å†™
            // Zè½´æ‹‰è¿‘åˆ° 2.5 (åŸä¸º 8)ï¼ŒYè½´å¾®è°ƒå¯¹å‡†é¢éƒ¨
            camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 100);
            camera.position.set(0, 0.3, 2.5);

            renderer = new THREE.WebGLRenderer({ alpha: true, antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            renderer.toneMapping = THREE.ACESFilmicToneMapping;
            renderer.toneMappingExposure = 1.0;
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            container.appendChild(renderer.domElement);

            // ğŸ’¡ HDRI çº§å…‰ç…§ç¯å¢ƒ (Studio Lighting)
            if (window.RoomEnvironment) {
                const pmremGenerator = new THREE.PMREMGenerator(renderer);
                pmremGenerator.compileEquirectangularShader();
                const roomEnvironment = new window.RoomEnvironment();
                scene.environment = pmremGenerator.fromScene(roomEnvironment).texture;
            }

            // è¾…åŠ©è¡¥å…‰ (å¢å¼ºè½®å»“å’Œçœ¼ç¥)
            // è½®å»“å…‰ (Rim Light) - æä¾›èƒŒéƒ¨è¾¹ç¼˜é«˜å…‰ï¼Œè“ç´«è‰²è°ƒ
            const rimLight = new THREE.SpotLight(0x4455ff, 5.0);
            rimLight.position.set(-2, 2, -2);
            rimLight.lookAt(0, 0, 0);
            scene.add(rimLight);

            // çœ¼ç¥å…‰ (Eye Light) - å¾®å¼±çš„ä¸€ç‚¹ç‚¹ï¼Œç‚¹äº®çœ¼ç›
            const pointLight = new THREE.PointLight(0xffffff, 0.5);
            pointLight.position.set(0, 0.5, 2);
            scene.add(pointLight);

            // ğŸ® OrbitControls æ§åˆ¶å™¨ (é»˜è®¤ç¦ç”¨)
            if (window.OrbitControls) {
                controls = new window.OrbitControls(camera, renderer.domElement);
                controls.listenToKeyEvents(window); // ğŸ‘ˆ å¯ç”¨é”®ç›˜æ§åˆ¶
                controls.enableDamping = true;
                controls.dampingFactor = 0.05;
                controls.screenSpacePanning = true; // ğŸ‘ˆ å±å¹•ç©ºé—´å¹³ç§» (ä¸Šä¸‹å·¦å³)
                controls.enabled = false; // é»˜è®¤å…³é—­ï¼ŒæŒ‰Cå¼€å¯
            }

            // âŒ¨ï¸ æŒ‰ä¸‹ 'C' é”®åˆ‡æ¢ç›¸æœºç¼–è¾‘æ¨¡å¼
            window.addEventListener('keydown', (e) => {
                const container = document.getElementById('scene-container');
                if (e.key.toLowerCase() === 'c') {
                    isCameraEditing = !isCameraEditing;
                    if (controls) controls.enabled = isCameraEditing;

                    if (isCameraEditing) {
                        console.log('ğŸ”§ ç›¸æœºç¼–è¾‘æ¨¡å¼: ON (ä½¿ç”¨é¼ æ ‡/æ–¹å‘é”®è°ƒæ•´)');
                        document.body.style.cursor = 'move';
                        if (container) container.style.pointerEvents = 'auto'; // ğŸ‘ˆ å…è®¸äº¤äº’
                    } else {
                        console.log('ğŸ”§ ç›¸æœºç¼–è¾‘æ¨¡å¼: OFF (å‚æ•°å·²ä¿å­˜)');
                        document.body.style.cursor = 'default';
                        if (container) container.style.pointerEvents = 'none'; // ğŸ‘ˆ æ¢å¤ç©¿é€
                        saveCameraSettings();
                    }
                }
            });

            loadGLBModels();
            window.addEventListener('resize', onWindowResize);
        }

        // åŠ è½½GLBæ¨¡å‹
        async function loadGLBModels() {
            console.log('ğŸ± å¼€å§‹åŠ è½½GLBæ¨¡å‹...');

            // æ­¤æ—¶ GLTFLoader åº”è¯¥å·²ç»åœ¨ window ä¸Šäº†
            if (!window.GLTFLoader) {
                console.error('âŒ GLTFLoaderæœªåŠ è½½ï¼Œä½¿ç”¨å¤‡ç”¨æ¨¡å‹');
                createFallbackModel();
                return;
            }

            glbLoader = new window.GLTFLoader();

            try {
                // é¢„åŠ è½½ä¸¤ä¸ªæ¨¡å‹
                const [model1, model2] = await Promise.all([
                    loadSingleGLB('models/cat.glb'),
                    loadSingleGLB('models/cat-2.glb')
                ]);

                catModel1 = model1;
                catModel2 = model2;

                // é»˜è®¤æ˜¾ç¤ºæ¡æ‹³æ¨¡å‹
                catModel = catModel1;
                scene.add(catModel);
                currentModelState = 'closed';
                modelsLoaded = true;

                console.log('âœ… ä¸¤ä¸ªGLBæ¨¡å‹åŠ è½½æˆåŠŸ');
            } catch (error) {
                console.error('âŒ GLBæ¨¡å‹åŠ è½½å¤±è´¥:', error);
                createFallbackModel();
            }
        }

        // åŠ è½½å•ä¸ªGLBæ–‡ä»¶
        function loadSingleGLB(path) {
            return new Promise((resolve, reject) => {
                glbLoader.load(
                    path,
                    (gltf) => {
                        const model = gltf.scene;
                        model.scale.set(1.5, 1.5, 1.5);
                        model.position.set(0, 0, 0);
                        console.log(`âœ… åŠ è½½æˆåŠŸ: ${path}`);
                        resolve(model);
                    },
                    (xhr) => {
                        const percent = (xhr.loaded / xhr.total * 100).toFixed(0);
                        console.log(`ğŸ“¦ ${path}: ${percent}%`);
                    },
                    (error) => {
                        console.error(`âŒ åŠ è½½å¤±è´¥ ${path}:`, error);
                        reject(error);
                    }
                );
            });
        }

        // åˆ‡æ¢æ¨¡å‹
        function switchCatModel(newState) {
            if (!modelsLoaded || currentModelState === newState) return;

            // ç§»é™¤å½“å‰æ¨¡å‹
            if (catModel) {
                scene.remove(catModel);
            }

            // åˆ‡æ¢åˆ°æ–°æ¨¡å‹
            if (newState === 'closed' && catModel1) {
                catModel = catModel1;
                currentModelName = 'cat.glb';
                console.log('ğŸ”„ åˆ‡æ¢åˆ°æ¡æ‹³æ¨¡å‹ (cat.glb)');
            } else if (newState === 'open' && catModel2) {
                catModel = catModel2;
                currentModelName = 'cat-2.glb';
                console.log('ğŸ”„ åˆ‡æ¢åˆ°å¼ å¼€æ¨¡å‹ (cat-2.glb)');
            }

            scene.add(catModel);
            currentModelState = newState;

            // å°è¯•åº”ç”¨ç›¸æœºè§†è§’
            if (currentModelName) {
                applyCameraSettings(currentModelName);
            } else {
                console.warn('âš ï¸ æœªçŸ¥æ¨¡å‹åç§°ï¼Œè·³è¿‡è§†è§’åº”ç”¨');
            }
        }

        // åˆ›å»ºç¨‹åºåŒ–å¤‡ç”¨æ¨¡å‹
        function createFallbackModel() {
            console.log('ğŸ± ä½¿ç”¨ç¨‹åºåŒ–å¤‡ç”¨æ¨¡å‹...');
            catModel = new THREE.Group();

            const furMaterial = new THREE.MeshPhongMaterial({ color: 0xff9966, shininess: 30 });
            const eyeWhiteMaterial = new THREE.MeshPhongMaterial({ color: 0xffffff });
            const pupilMaterial = new THREE.MeshPhongMaterial({ color: 0x1a1a1a });

            const head = new THREE.Mesh(new THREE.SphereGeometry(1.2, 32, 32), furMaterial);
            head.scale.set(1, 0.95, 0.9);
            catModel.add(head);

            const leftEar = new THREE.Mesh(new THREE.ConeGeometry(0.4, 0.8, 8), furMaterial);
            leftEar.position.set(-0.7, 1.0, 0.1);
            leftEar.rotation.z = -0.3;
            catModel.add(leftEar);

            const rightEar = new THREE.Mesh(new THREE.ConeGeometry(0.4, 0.8, 8), furMaterial);
            rightEar.position.set(0.7, 1.0, 0.1);
            rightEar.rotation.z = 0.3;
            catModel.add(rightEar);

            const leftEyeGroup = new THREE.Group();
            leftEyeGroup.add(new THREE.Mesh(new THREE.SphereGeometry(0.25, 16, 16), eyeWhiteMaterial));
            const leftPupil = new THREE.Mesh(new THREE.SphereGeometry(0.15, 16, 16), pupilMaterial);
            leftPupil.position.z = 0.18;
            leftEyeGroup.add(leftPupil);
            leftEyeGroup.position.set(-0.5, 0.3, 0.8);
            leftEyeGroup.name = 'leftEye';
            catModel.add(leftEyeGroup);

            const rightEyeGroup = new THREE.Group();
            rightEyeGroup.add(new THREE.Mesh(new THREE.SphereGeometry(0.25, 16, 16), eyeWhiteMaterial));
            const rightPupil = new THREE.Mesh(new THREE.SphereGeometry(0.15, 16, 16), pupilMaterial);
            rightPupil.position.z = 0.18;
            rightEyeGroup.add(rightPupil);
            rightEyeGroup.position.set(0.5, 0.3, 0.8);
            rightEyeGroup.name = 'rightEye';
            catModel.add(rightEyeGroup);

            const body = new THREE.Mesh(new THREE.SphereGeometry(1, 32, 32), furMaterial);
            body.position.set(0, -2, 0);
            body.scale.set(1.1, 1.3, 0.9);
            catModel.add(body);

            catModel.position.y = 0.5;
            scene.add(catModel);
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        // æ¸²æŸ“å¾ªç¯
        function animate() {
            requestAnimationFrame(animate);

            // DOMå‘¼å¸ç¯
            updateChargingEffect();

            // ğŸ® æ›´æ–°ç›¸æœºæ§åˆ¶å™¨
            if (controls && isCameraEditing) {
                controls.update();
            }

            // æ ¹æ®æ‰‹åŠ¿çŠ¶æ€åˆ‡æ¢æ¨¡å‹
            if (handDetected && modelsLoaded) {
                const desiredState = isHandOpen ? 'open' : 'closed';
                switchCatModel(desiredState);
            }

            if (catModel) {
                const inputX = useHandTracking && handDetected ? handPosition.x : mouseX;
                const inputY = useHandTracking && handDetected ? handPosition.y : mouseY;

                // --- æ ¸å¿ƒä¿®æ”¹ï¼šæ¨¡å‹ä½ç½®å›ºå®šï¼Œä»…çœ¼ç¥è·Ÿæ‰‹ ---

                // 1. ä½ç½®å›ºå®šåœ¨ç”»é¢ä¸­å¿ƒ
                const targetY = -0.5;
                catModel.position.x = 0;
                catModel.position.y += (targetY - catModel.position.y) * 0.1;
                catModel.position.z = 0;

                // 2. å¤´éƒ¨å¾®åŠ¨ (å¹…åº¦å¾ˆå°)
                // ä¿®å¤ï¼šç§»é™¤Yè½´è¾“å…¥çš„è´Ÿå·ï¼Œè§£å†³ä¸Šä¸‹åå‘é—®é¢˜
                targetRotation.y = inputX * 0.3;
                targetRotation.x = inputY * 0.2; // åŸä¸º -inputY * 0.2

                currentRotation.x += (targetRotation.x - currentRotation.x) * 0.1;
                currentRotation.y += (targetRotation.y - currentRotation.y) * 0.1;

                catModel.rotation.y = currentRotation.y;
                catModel.rotation.x = currentRotation.x;

                // 3. çœ¼ç¥è·Ÿéš (å°è¯•æŸ¥æ‰¾çœ¼çƒèŠ‚ç‚¹)
                catModel.traverse((child) => {
                    if (child.isMesh && (child.name.toLowerCase().includes('eye'))) {
                        child.rotation.y = inputX * 0.5;
                        child.rotation.x = inputY * 0.3; // åŸä¸º -inputY * 0.3
                    }
                });

                // å‘¼å¸åŠ¨ç”»
                const time = Date.now() * 0.001;
                catModel.position.y += Math.sin(time * 1.5) * 0.002;
            }

            updateFireworks();
            renderer.render(scene, camera);
        }

        window.addEventListener('load', init);
    </script>
</body>

</html>