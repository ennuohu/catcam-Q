<!DOCTYPE html>
<html lang="zh-CN">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <title>çŒ«å’ªæ‰‹åŠ¿è·Ÿè¸ª - æ‰‹æœºç‰ˆ</title>
    <link rel="stylesheet" href="style.css">
</head>

<body>
    <!-- åŠ è½½æç¤º -->
    <div id="loading">
        <div class="spinner"></div>
        <p id="load-status">æ­£åœ¨åŠ è½½...</p>
        <p class="hint" id="load-hint">è¯·ç¨å€™</p>
    </div>

    <!-- ä¸»å®¹å™¨ -->
    <div id="app">
        <!-- è§†é¢‘æµ -->
        <video id="webcam" autoplay playsinline style="position:absolute;opacity:0;width:1px;height:1px;"></video>

        <!-- Canvasç”¨äºæ‰‹åŠ¿å¯è§†åŒ–ï¼ˆå¯é€‰ï¼‰ -->
        <canvas id="output-canvas"
            style="position:absolute;top:0;left:0;width:100%;height:100%;opacity:0;z-index:1;"></canvas>

        <!-- Three.jsåœºæ™¯ -->
        <div id="scene-container"></div>

        <!-- çŠ¶æ€æŒ‡ç¤º -->
        <div id="status">
            <div class="status-dot"></div>
            <span id="status-text">åˆå§‹åŒ–ä¸­...</span>
        </div>

        <!-- åˆ‡æ¢æ¨¡å¼æŒ‰é’® -->
        <button id="mode-toggle"
            style="position:fixed;bottom:20px;right:20px;padding:12px 20px;background:rgba(255,255,255,0.2);border:none;border-radius:25px;color:white;font-size:14px;cursor:pointer;z-index:100;">
            åˆ‡æ¢åˆ°é¼ æ ‡æ¨¡å¼
        </button>
    </div>

    <!-- Three.js -->
    <script src="https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.js"></script>

    <!-- MediaPipe (æ‡’åŠ è½½) -->
    <script>
        // å…¨å±€å˜é‡
        let camera, scene, renderer, catModel;
        let videoElement, canvasElement, canvasCtx;
        let hands, cameraHelper;
        let handDetected = false;
        let handPosition = { x: 0, y: 0 };
        let targetRotation = { x: 0, y: 0 };
        let currentRotation = { x: 0, y: 0 };
        let mouseX = 0, mouseY = 0;
        let useHandTracking = true;
        let mediaPipeLoaded = false;

        // æ›´æ–°åŠ è½½çŠ¶æ€
        function updateLoadStatus(status, hint = '') {
            document.getElementById('load-status').textContent = status;
            if (hint) document.getElementById('load-hint').textContent = hint;
            console.log(status, hint);
        }

        // åˆå§‹åŒ–
        async function init() {
            console.log('ğŸš€ åˆå§‹åŒ–åº”ç”¨...');
            updateLoadStatus('åˆå§‹åŒ–Three.js...', '');

            // æ£€æŸ¥THREE
            if (typeof THREE === 'undefined') {
                alert('Three.jsåŠ è½½å¤±è´¥ï¼Œè¯·åˆ·æ–°');
                return;
            }

            // åˆå§‹åŒ–3Dåœºæ™¯
            initThreeJS();

            // å°è¯•åˆå§‹åŒ–æ‰‹åŠ¿è·Ÿè¸ª
            updateLoadStatus('æ­£åœ¨åŠ è½½æ‰‹åŠ¿è¯†åˆ«...', 'è¿™å¯èƒ½éœ€è¦å‡ ç§’é’Ÿ');

            try {
                await loadMediaPipe();
                await initCamera();
                await initHandTracking();
                useHandTracking = true;
                document.getElementById('status-text').textContent = 'ç­‰å¾…æ£€æµ‹æ‰‹æŒ...';
            } catch (error) {
                console.warn('æ‰‹åŠ¿è·Ÿè¸ªåˆå§‹åŒ–å¤±è´¥ï¼Œä½¿ç”¨è§¦æ‘¸æ¨¡å¼:', error);
                useHandTracking = false;
                setupTouchMode();
                document.getElementById('status-text').textContent = 'è§¦æ‘¸å±å¹•æ§åˆ¶çŒ«å’ª';
                document.getElementById('mode-toggle').textContent = 'æ‰‹åŠ¿æ¨¡å¼ä¸å¯ç”¨';
                document.getElementById('mode-toggle').disabled = true;
            }

            // å¼€å§‹æ¸²æŸ“
            animate();

            // éšè—åŠ è½½ç•Œé¢
            setTimeout(() => {
                document.getElementById('loading').classList.add('hidden');
                document.getElementById('app').classList.add('active');
            }, 500);

            console.log('âœ… åº”ç”¨åˆå§‹åŒ–å®Œæˆ');
        }

        // åŠ è½½MediaPipeåº“
        function loadMediaPipe() {
            return new Promise((resolve, reject) => {
                const timeout = setTimeout(() => {
                    reject(new Error('MediaPipeåŠ è½½è¶…æ—¶'));
                }, 15000); // 15ç§’è¶…æ—¶

                let loaded = 0;
                const scripts = [
                    'https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js',
                    'https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js',
                    'https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js'
                ];

                function loadScript(src) {
                    return new Promise((res, rej) => {
                        const script = document.createElement('script');
                        script.src = src;
                        script.onload = () => res();
                        script.onerror = () => rej(new Error(`Failed to load ${src}`));
                        document.head.appendChild(script);
                    });
                }

                Promise.all(scripts.map(loadScript))
                    .then(() => {
                        clearTimeout(timeout);
                        mediaPipeLoaded = true;
                        console.log('âœ… MediaPipeåŠ è½½æˆåŠŸ');
                        resolve();
                    })
                    .catch((err) => {
                        clearTimeout(timeout);
                        reject(err);
                    });
            });
        }

        // åˆå§‹åŒ–æ‘„åƒå¤´
        async function initCamera() {
            updateLoadStatus('è¯·æ±‚æ‘„åƒå¤´æƒé™...', '');
            videoElement = document.getElementById('webcam');
            canvasElement = document.getElementById('output-canvas');
            canvasCtx = canvasElement.getContext('2d');

            try {
                const stream = await navigator.mediaDevices.getUserMedia({
                    video: {
                        facingMode: 'user',
                        width: { ideal: 640 },
                        height: { ideal: 480 }
                    },
                    audio: false
                });

                videoElement.srcObject = stream;

                await new Promise((resolve) => {
                    videoElement.onloadedmetadata = () => {
                        canvasElement.width = videoElement.videoWidth;
                        canvasElement.height = videoElement.videoHeight;
                        resolve();
                    };
                });

                console.log('âœ… æ‘„åƒå¤´åˆå§‹åŒ–æˆåŠŸ');
            } catch (error) {
                throw new Error('æ‘„åƒå¤´è®¿é—®å¤±è´¥: ' + error.message);
            }
        }

        // åˆå§‹åŒ–æ‰‹åŠ¿è·Ÿè¸ª
        async function initHandTracking() {
            if (!mediaPipeLoaded || typeof Hands === 'undefined') {
                throw new Error('MediaPipeæœªåŠ è½½');
            }

            updateLoadStatus('åˆå§‹åŒ–æ‰‹åŠ¿è¯†åˆ«...', '');

            hands = new Hands({
                locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`
            });

            hands.setOptions({
                maxNumHands: 1,
                modelComplexity: 0, // ä½¿ç”¨æœ€è½»é‡çº§æ¨¡å‹
                minDetectionConfidence: 0.5,
                minTrackingConfidence: 0.5
            });

            hands.onResults(onHandResults);

            // å¯åŠ¨æ‘„åƒå¤´å¤„ç†
            cameraHelper = new Camera(videoElement, {
                onFrame: async () => {
                    await hands.send({ image: videoElement });
                },
                width: 640,
                height: 480
            });
            cameraHelper.start();

            console.log('âœ… æ‰‹åŠ¿è·Ÿè¸ªåˆå§‹åŒ–æˆåŠŸ');
        }

        // æ‰‹åŠ¿æ£€æµ‹ç»“æœå¤„ç†
        function onHandResults(results) {
            // æ¸…ç©ºcanvas
            canvasCtx.save();
            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);

            if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
                const landmarks = results.multiHandLandmarks[0];

                // å¯é€‰ï¼šç»˜åˆ¶æ‰‹åŠ¿ï¼ˆè°ƒè¯•ç”¨ï¼‰
                // drawConnectors(canvasCtx, landmarks, HAND_CONNECTIONS, {color: '#00FF00', lineWidth: 2});

                // è·å–æ‰‹æŒä¸­å¿ƒï¼ˆlandmark 9ï¼‰
                const palmCenter = landmarks[9];

                // è½¬æ¢åæ ‡
                handPosition.x = (1 - palmCenter.x) * 2 - 1;
                handPosition.y = palmCenter.y * 2 - 1;

                handDetected = true;
                updateStatus(true);
            } else {
                handDetected = false;
                updateStatus(false);
            }

            canvasCtx.restore();
        }

        // è®¾ç½®è§¦æ‘¸æ¨¡å¼
        function setupTouchMode() {
            document.addEventListener('mousemove', onPointerMove);
            document.addEventListener('touchmove', onTouchMove);
        }

        function onPointerMove(event) {
            mouseX = (event.clientX / window.innerWidth) * 2 - 1;
            mouseY = (event.clientY / window.innerHeight) * 2 - 1;
        }

        function onTouchMove(event) {
            event.preventDefault();
            if (event.touches.length > 0) {
                mouseX = (event.touches[0].clientX / window.innerWidth) * 2 - 1;
                mouseY = (event.touches[0].clientY / window.innerHeight) * 2 - 1;
            }
        }

        // æ›´æ–°çŠ¶æ€æ˜¾ç¤º
        function updateStatus(detected) {
            const dot = document.querySelector('.status-dot');
            const text = document.getElementById('status-text');

            if (useHandTracking) {
                if (detected) {
                    dot.classList.add('active');
                    text.textContent = 'ğŸ‘‹ æ£€æµ‹åˆ°æ‰‹æŒ';
                } else {
                    dot.classList.remove('active');
                    text.textContent = 'ç­‰å¾…æ£€æµ‹æ‰‹æŒ...';
                }
            } else {
                dot.classList.add('active');
                text.textContent = 'è§¦æ‘¸å±å¹•æ§åˆ¶çŒ«å’ª';
            }
        }

        // Three.jsåœºæ™¯åˆå§‹åŒ–
        function initThreeJS() {
            const container = document.getElementById('scene-container');
            scene = new THREE.Scene();
            scene.background = null;

            camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.z = 8;

            renderer = new THREE.WebGLRenderer({ alpha: true, antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2)); // é™åˆ¶ç§»åŠ¨ç«¯åƒç´ æ¯”
            container.appendChild(renderer.domElement);

            // å…‰ç…§
            scene.add(new THREE.AmbientLight(0xffffff, 0.6));
            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight.position.set(5, 5, 5);
            scene.add(directionalLight);
            const pointLight = new THREE.PointLight(0xff9999, 0.5);
            pointLight.position.set(-5, 3, 3);
            scene.add(pointLight);

            createCatModel();

            window.addEventListener('resize', onWindowResize);
        }

        // åˆ›å»ºçŒ«å’ªæ¨¡å‹
        function createCatModel() {
            catModel = new THREE.Group();

            const furMaterial = new THREE.MeshPhongMaterial({ color: 0xff9966, shininess: 30 });
            const noseMaterial = new THREE.MeshPhongMaterial({ color: 0xff6b9d, shininess: 50 });
            const eyeWhiteMaterial = new THREE.MeshPhongMaterial({ color: 0xffffff });
            const pupilMaterial = new THREE.MeshPhongMaterial({ color: 0x1a1a1a });

            // å¤´éƒ¨
            const head = new THREE.Mesh(new THREE.SphereGeometry(1.2, 32, 32), furMaterial);
            head.scale.set(1, 0.95, 0.9);
            catModel.add(head);

            // è€³æœµ
            const leftEar = new THREE.Mesh(new THREE.ConeGeometry(0.4, 0.8, 8), furMaterial);
            leftEar.position.set(-0.7, 1.0, 0.1);
            leftEar.rotation.z = -0.3;
            catModel.add(leftEar);

            const rightEar = new THREE.Mesh(new THREE.ConeGeometry(0.4, 0.8, 8), furMaterial);
            rightEar.position.set(0.7, 1.0, 0.1);
            rightEar.rotation.z = 0.3;
            catModel.add(rightEar);

            // çœ¼ç›
            const leftEyeGroup = new THREE.Group();
            leftEyeGroup.add(new THREE.Mesh(new THREE.SphereGeometry(0.25, 16, 16), eyeWhiteMaterial));
            const leftPupil = new THREE.Mesh(new THREE.SphereGeometry(0.15, 16, 16), pupilMaterial);
            leftPupil.position.z = 0.18;
            leftEyeGroup.add(leftPupil);
            leftEyeGroup.position.set(-0.5, 0.3, 0.8);
            leftEyeGroup.name = 'leftEye';
            catModel.add(leftEyeGroup);

            const rightEyeGroup = new THREE.Group();
            rightEyeGroup.add(new THREE.Mesh(new THREE.SphereGeometry(0.25, 16, 16), eyeWhiteMaterial));
            const rightPupil = new THREE.Mesh(new THREE.SphereGeometry(0.15, 16, 16), pupilMaterial);
            rightPupil.position.z = 0.18;
            rightEyeGroup.add(rightPupil);
            rightEyeGroup.position.set(0.5, 0.3, 0.8);
            rightEyeGroup.name = 'rightEye';
            catModel.add(rightEyeGroup);

            // é¼»å­
            const nose = new THREE.Mesh(new THREE.SphereGeometry(0.15, 16, 16), noseMaterial);
            nose.position.set(0, -0.1, 1.1);
            nose.scale.set(0.7, 0.6, 0.5);
            catModel.add(nose);

            // èƒ¡é¡»
            const whiskerMaterial = new THREE.LineBasicMaterial({ color: 0x333333 });
            [[new THREE.Vector3(-0.3, -0.2, 1.0), new THREE.Vector3(-1.5, -0.1, 1.0)],
            [new THREE.Vector3(-0.3, -0.3, 1.0), new THREE.Vector3(-1.5, -0.3, 1.0)],
            [new THREE.Vector3(0.3, -0.2, 1.0), new THREE.Vector3(1.5, -0.1, 1.0)],
            [new THREE.Vector3(0.3, -0.3, 1.0), new THREE.Vector3(1.5, -0.3, 1.0)]
            ].forEach(points => {
                catModel.add(new THREE.Line(new THREE.BufferGeometry().setFromPoints(points), whiskerMaterial));
            });

            // èº«ä½“
            const body = new THREE.Mesh(new THREE.SphereGeometry(1, 32, 32), furMaterial);
            body.position.set(0, -2, 0);
            body.scale.set(1.1, 1.3, 0.9);
            catModel.add(body);

            catModel.position.y = 0.5;
            scene.add(catModel);
        }

        // çª—å£è°ƒæ•´
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        // æ¸²æŸ“å¾ªç¯
        function animate() {
            requestAnimationFrame(animate);

            if (catModel) {
                // æ ¹æ®æ¨¡å¼é€‰æ‹©è¾“å…¥æº
                const inputX = useHandTracking && handDetected ? handPosition.x : mouseX;
                const inputY = useHandTracking && handDetected ? handPosition.y : mouseY;

                // è®¡ç®—ç›®æ ‡æ—‹è½¬
                targetRotation.y = inputX * 0.5;
                targetRotation.x = -inputY * 0.3;

                // å¹³æ»‘è¿‡æ¸¡
                const smoothFactor = 0.1;
                currentRotation.x += (targetRotation.x - currentRotation.x) * smoothFactor;
                currentRotation.y += (targetRotation.y - currentRotation.y) * smoothFactor;

                // åº”ç”¨æ—‹è½¬
                catModel.rotation.y = currentRotation.y;
                catModel.rotation.x = currentRotation.x;

                // çœ¼ç›è·Ÿéš
                const leftEye = catModel.getObjectByName('leftEye');
                const rightEye = catModel.getObjectByName('rightEye');
                if (leftEye && rightEye) {
                    const eyeRotation = inputX * 0.3;
                    leftEye.rotation.y = eyeRotation;
                    rightEye.rotation.y = eyeRotation;
                }

                // å‘¼å¸åŠ¨ç”»
                const time = Date.now() * 0.001;
                catModel.position.y = 0.5 + Math.sin(time * 2) * 0.05;
            }

            renderer.render(scene, camera);
        }

        // æ¨¡å¼åˆ‡æ¢
        document.getElementById('mode-toggle').addEventListener('click', function () {
            if (!mediaPipeLoaded) return;

            useHandTracking = !useHandTracking;
            this.textContent = useHandTracking ? 'åˆ‡æ¢åˆ°è§¦æ‘¸æ¨¡å¼' : 'åˆ‡æ¢åˆ°æ‰‹åŠ¿æ¨¡å¼';

            if (!useHandTracking) {
                setupTouchMode();
            }

            updateStatus(false);
        });

        // å¯åŠ¨
        window.addEventListener('load', init);
    </script>
</body>

</html>